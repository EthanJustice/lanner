#[macro_use]
// std

// crates
use pest_derive::*;
use pest::{error::Error, Parser};

// local
mod eval;
use eval::{evaluate_function, evaluate_simple_expression};

#[derive(Debug, Clone)]
pub enum LannerError {
    /// The given function has invalid syntax
    InvalidFunction,
    /// The given expression has invalid syntax
    InvalidExpression,
    /// The given input has invalid syntax
    InvalidInput,
    /// Something went wrong while parsing
    ParsingError(Error<Rule>),
    /// Something else went wrong
    Other(&'static str),
}

/// Represents an AstNode which lanner consumes when evaluating expressions.
#[derive(Debug, Clone)]
pub enum AstNode {
    /// Represents a function operation.
    ///
    /// Syntax: functionName(value)
    FunctionOp {
        /// Corresponds to functionName
        function: Function,
        /// Correspnds to value.
        /// This is the value that will be computed using the function.
        value: f64,
    },
    /// Represents an expression, such as "10 + 10"
    Expression {
        /// the number on the **l**eft-**h**and **s**ide of the expression
        lhs: f64,
        /// the number on the **r**ight-**h**and **s**ide of the expression
        rhs: f64,
        /// the operation being performed between the left and right-hand sides
        operator: Operation,
    },
    /// An error of some sorts. This will later be replaced by an enum
    Error(LannerError),
}

/// Function corresponds to a special function that don't have a symbol equivalent (e.g. addition has "+"). There are few functions now.
/// Functions in lanner are expressed as functionName(value), e.g. cos(10)
#[derive(Debug, Clone)]
pub enum Function {
    /// Cosign function
    Cos,
    /// Sine function
    Sin,
    /// Tangent function
    Tan,
    /// Square root function
    Sqrt,
}

/// Represents a type of basic arithmetic operation.
#[derive(Debug, Clone)]
pub enum Operation {
    /// Add corresponds to addition, e.g. "10 + 10" (20)
    Add,
    /// Subtract corresponds to subtraction, e.g. "10 - 10" (0)
    Subtract,
    /// Multiply corresponds to multiplication, e.g. "10 * 10" (100)
    Multiply,
    /// Divide corresponds to division, e.g. "100 / 10" (10)
    Divide,
    /// Modulo corresponds to modulo division, which is evaluated to the remainder after division, e.g. "10 / 9" = 1
    ///
    /// See [Modulo operation - Wikipedia](https://en.wikipedia.org/wiki/Modulo_operation) for more.
    Modulo,
    /// Exponent corresponds to exponentiation (base^power), e.g. "10^2" (100)
    Exponent,
    /// Root corresponds to the root of a number, e.g. "100^/2" (10; 100 is a perfect square)
    Root,
}

/// Parser generated by pest.
#[derive(Parser)]
#[grammar = "lib.pest"]
pub struct LannerParser;

/// Begins the parsing process of a given string (`src`).
pub fn parse(src: &str) -> Result<Vec<AstNode>, Error<Rule>> {
    let mut ast: Vec<AstNode> = Vec::new();

    let exp = LannerParser::parse(Rule::expression, src)?;
    for pair in exp {
        match pair.as_rule() {
            Rule::expression => {
                ast.push(parse_to_ast(pair));
            }
            _ => ast.push(AstNode::Error(LannerError::InvalidInput)),
        }
    }

    Ok(ast)
}

/// Parses a given expression into simple expressions and functions.
fn parse_to_ast(pair: pest::iterators::Pair<Rule>) -> AstNode {
    match pair.as_rule() {
        Rule::expression => parse_to_ast(pair.into_inner().next().unwrap()),
        Rule::simple_expression => {
            let mut pair = pair.into_inner();
            let lhs = pair.next().unwrap();
            let op = pair.next().unwrap();
            let rhs = pair.next().unwrap();
            parse_expression(op, lhs, rhs)
        }
        Rule::function => {
            let mut pair = pair.into_inner();
            let function = pair.next().unwrap();
            let value = pair.next().unwrap().as_str().parse::<f64>().unwrap();

            let function = parse_function(function);

            match function {
                Ok(function) => AstNode::FunctionOp { value, function },
                Err(error) => AstNode::Error(error.to_owned()),
            }
        }
        _ => AstNode::Error(LannerError::InvalidInput),
    }
}

/// Converts a given Pest rule into an Expression in the AST
fn parse_expression(
    operator: pest::iterators::Pair<Rule>,
    lhs: pest::iterators::Pair<Rule>,
    rhs: pest::iterators::Pair<Rule>,
) -> AstNode {
    AstNode::Expression {
        lhs: lhs.as_str().parse::<f64>().unwrap(),
        rhs: rhs.as_str().parse::<f64>().unwrap(),
        operator: parse_operator(operator),
    }
}

/// Converts a given Pest rule into an Operator in the AST
fn parse_operator(operator: pest::iterators::Pair<Rule>) -> Operation {
    match operator.as_str() {
        "+" => Operation::Add,
        "-" => Operation::Subtract,
        "*" => Operation::Multiply,
        "/" => Operation::Divide,
        "%" => Operation::Modulo,
        "^" => Operation::Exponent,
        "^/" => Operation::Root,
        _ => Operation::Add, // todo: fix
    }
}

/// Converts a given Pest rule into a Function in the AST
fn parse_function(function: pest::iterators::Pair<Rule>) -> Result<Function, LannerError> {
    match function.as_str() {
        "sin" => Ok(Function::Sin),
        "cos" => Ok(Function::Cos),
        "tan" => Ok(Function::Tan),
        "sqrt" => Ok(Function::Sqrt),
        _ => Err(LannerError::InvalidFunction),
    }
}

/// Evaluates a given expression, such as "10 + 10"
pub fn evaluate(src: &str) -> Result<f64, LannerError> {
    let ast = parse(src);
    match ast {
        Ok(ast) => {
            let pair = ast.get(0).unwrap();
            match pair {
                AstNode::FunctionOp {
                    function: _,
                    value: _,
                } => match evaluate_function(pair.to_owned()) {
                    Ok(result) => Ok(result),
                    Err(error) => Err(error.to_owned()),
                },
                AstNode::Expression {
                    lhs: _,
                    rhs: _,
                    operator: _,
                } => match evaluate_simple_expression(pair.to_owned()) {
                    Ok(result) => Ok(result),
                    Err(error) => Err(error.to_owned()),
                },
                AstNode::Error(error) => Err(error.to_owned()),
                _ => Err(LannerError::InvalidInput),
            }
        }
        Err(error) => Err(LannerError::ParsingError(error)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn parse_fn_test() {
        //        parse("20 + 20");
        //        parse("sin(20)");
    }

    #[test]
    fn addition_eval() {
        assert_eq!(evaluate("20 + 30").unwrap(), 50.0);
        assert_eq!(evaluate("-20 + 30").unwrap(), 10.0);
        assert_eq!(evaluate("-20 + -30").unwrap(), -50.0);
        assert_eq!(evaluate("-20.2 + 30").unwrap(), 9.8);
        assert_eq!(evaluate("10.1 + .1").unwrap(), 10.2);
    }

    #[test]
    fn subtraction_eval() {
        assert_eq!(evaluate("30 - 30").unwrap(), 0.0);
        assert_eq!(evaluate("20 - 30").unwrap(), -10.0);
        assert_eq!(evaluate("-20 - 30").unwrap(), -50.0);
        assert_eq!(evaluate("-20 - -30").unwrap(), 10.0);
        assert_eq!(evaluate("-20.2 - 30").unwrap(), -50.2);
        assert_eq!(evaluate("10.2 - 0.2").unwrap(), 10.0);
    }

    #[test]
    fn multiplication_eval() {
        assert_eq!(evaluate("30 * 30").unwrap(), 900.0);
        assert_eq!(evaluate("-30 * 30").unwrap(), -900.0);
        assert_eq!(evaluate("-20 * -30").unwrap(), 600.0);
        assert_eq!(evaluate("-20.2 * 30").unwrap(), -606.0);
        assert_eq!(evaluate("-20.2 * -30.3").unwrap(), 612.06);
    }

    #[test]
    fn division_eval() {
        assert_eq!(evaluate("30 / 30").unwrap(), 1.0);
        assert_eq!(evaluate("-30 / 30").unwrap(), -1.0);
        assert_eq!(evaluate("-20 / -30").unwrap(), 0.6666666666666666);
        assert_eq!(evaluate("-1.2 / 2").unwrap(), -0.6);
        assert_eq!(evaluate("-1.2 / -2").unwrap(), 0.6);
    }

    #[test]
    fn exponent_eval() {
        assert_eq!(evaluate("10 ^ 3").unwrap(), 1000.0);
        assert_eq!(evaluate("-10 ^ 2").unwrap(), 100.0);
        assert_eq!(evaluate("-10 ^ -2").unwrap(), 0.01);
        assert_eq!(evaluate("-10.2 ^ -0.5").unwrap().is_nan(), true);
    }

    #[test]
    fn test_cos() {
        assert_eq!(evaluate("cos(100)").unwrap(), 0.8623188722876839);
    }

    #[test]
    fn test_tan() {
        assert_eq!(evaluate("tan(500)").unwrap(), 0.52924386474448);
    }

    #[test]
    fn test_sin() {
        assert_eq!(evaluate("sin(1000)").unwrap(), 0.8268795405320025);
    }

    #[test]
    fn test_sqrt() {
        assert_eq!(evaluate("sqrt(100)").unwrap(), 10.0);
    }
}

#[cfg(test)]
mod parser_tests {
    use super::*;

    #[test]
    fn check_number() {
        let whole = LannerParser::parse(Rule::number, "10");
        assert!(whole.is_ok());
        let integer = LannerParser::parse(Rule::number, "10.15");
        assert!(integer.is_ok());
    }

    #[test]
    fn check_fn() {
        let function = LannerParser::parse(Rule::function, "cos(20)");
        assert!(function.is_ok());
    }

    #[test]
    fn check_operators() {}

    #[test]
    fn check_expression() {
        let exp = LannerParser::parse(Rule::expression, "10+10");
        assert!(exp.is_ok());

        let exp_with_spaces = LannerParser::parse(Rule::expression, "10 + 10");
        assert!(exp_with_spaces.is_ok());
    }
}

#[macro_use]
// std

// crates
use pest_derive::*;
use lazy_static::lazy_static;
use pest::{
    error::Error,
    iterators::{Pair, Pairs},
    prec_climber::{Assoc, Operator, PrecClimber},
    Parser,
};

// local
mod eval;
use eval::{evaluate_constant, evaluate_function, evaluate_simple_expression};

mod conversions;
use conversions::LannerUnit as Unit;

mod constants;

#[derive(Debug, Clone)]
pub enum LannerError {
    /// The given constant is invalid/nonexistent
    InvalidConstant,
    /// The given function has invalid syntax
    InvalidFunction,
    /// The given expression has invalid syntax
    InvalidExpression,
    /// The given input has invalid syntax
    InvalidInput,
    /// Something went wrong while parsing
    ParsingError(Error<Rule>),
    /// Something else went wrong
    Other(&'static str),
}

impl LannerError {
    pub fn to_string(&self) -> String {
        match self {
            LannerError::InvalidConstant => {
                "Invalid constant. Make sure your constant is supported/spelled correctly."
                    .to_string()
            }
            LannerError::InvalidFunction => {
                "Invalid function. Make sure your function is valid or supported by Lanner."
                    .to_string()
            }
            LannerError::InvalidExpression => {
                "Invalid expression. Make sure your expression is valid.".to_string()
            }
            LannerError::InvalidInput => {
                "Invalid input. Make sure your input is valid Lanner grammar".to_string()
            }
            LannerError::ParsingError(r) => {
                let mut error = String::from("Parsing error on line ");
                let (line, col) = match r.line_col {
                    pest::error::LineColLocation::Pos((line, col)) => (line, col),
                    pest::error::LineColLocation::Span((line, col), (_, _)) => (line, col),
                };
                error.push_str(line.to_string().as_str());
                error.push_str(col.to_string().as_str());
                error
            }
            LannerError::Other(value) => value.to_string(),
        }
    }
}

/// Represents an AstNode which lanner consumes when evaluating expressions.
#[derive(Debug, Clone)]
pub enum AstNode {
    Conversion {
        to: Unit,
        from: Unit,
        value: f64,
    },
    /// Represents a function operation.
    ///
    /// Syntax: functionName(value)
    FunctionOp {
        /// Corresponds to functionName
        function: Function,
        /// Correspnds to value.
        /// This is the value that will be computed using the function.
        value: f64,
    },
    /// Constants
    Constant(Constant),
    /// Represents an expression, such as "10 + 10"
    Expression {
        /// the number on the **l**eft-**h**and **s**ide of the expression
        lhs: f64,
        /// the number on the **r**ight-**h**and **s**ide of the expression
        rhs: f64,
        /// the operation being performed between the left and right-hand sides
        operator: Operation,
    },
    /// Value of an operation
    Value(f64),
    /// An error of some sorts. This will later be replaced by an enum
    Error(LannerError),
}

/// Represents a constant
#[derive(Debug, Clone)]
pub enum Constant {
    E,
    Pi,
    Tau,
    I,
}

/// Function corresponds to a special function that don't have a symbol equivalent (e.g. addition has "+"). There are few functions now.
/// Functions in lanner are expressed as functionName(value), e.g. cos(10)
#[derive(Debug, Clone)]
pub enum Function {
    /// Cosign function
    Cos,
    /// Sine function
    Sin,
    /// Tangent function
    Tan,
    /// Square root function
    Sqrt,
    /// Absolute value function
    Abs,
}

/// Represents a type of basic arithmetic operation.
#[derive(Debug, Clone)]
pub enum Operation {
    /// Add corresponds to addition, e.g. "10 + 10" (20)
    Add,
    /// Subtract corresponds to subtraction, e.g. "10 - 10" (0)
    Subtract,
    /// Multiply corresponds to multiplication, e.g. "10 * 10" (100)
    Multiply,
    /// Divide corresponds to division, e.g. "100 / 10" (10)
    Divide,
    /// Modulo corresponds to modulo division, which is evaluated to the remainder after division, e.g. "10 / 9" = 1
    ///
    /// See [Modulo operation - Wikipedia](https://en.wikipedia.org/wiki/Modulo_operation) for more.
    Modulo,
    /// Exponent corresponds to exponentiation (base^power), e.g. "10^2" (100)
    Exponent,
    /// Root corresponds to the root of a number, e.g. "100^/2" (10; 100 is a perfect square)
    Root,
}

/// A Lanner context
pub struct Context {}

impl Context {}

/// Parser generated by pest.
#[derive(Parser)]
#[grammar = "lib.pest"]
pub struct LannerParser;

lazy_static! {
    static ref PREC_CLIMBER: PrecClimber<Rule> = {
        use Assoc::*;
        use Rule::*;

        PrecClimber::new(vec![
            Operator::new(add, Left) | Operator::new(subtract, Left),
            Operator::new(multiply, Left) | Operator::new(divide, Left),
            Operator::new(exponent, Right),
        ])
    };
}

/// Begins the parsing process of a given string (`src`).
pub fn parse(src: &str) -> Result<Vec<AstNode>, Error<Rule>> {
    let mut ast: Vec<AstNode> = Vec::new();

    let exp = LannerParser::parse(Rule::expression, src)?;
    for pair in exp {
        match pair.as_rule() {
            Rule::expression => {
                ast.push(parse_to_ast(pair));
            }
            _ => ast.push(AstNode::Error(LannerError::InvalidInput)),
        }
    }

    Ok(ast)
}

/// Parses a given expression into simple expressions and functions.
fn parse_to_ast(pair: pest::iterators::Pair<Rule>) -> AstNode {
    match pair.as_rule() {
        Rule::expression => parse_to_ast(pair.into_inner().next().unwrap()),
        Rule::simple_expression => match pair.as_rule() {
            //            Rule::simple_expression => parse_to_ast(pair),
            // above causes a stack overflow, it's an infinite loop caused when using order of operations
            _ => {
                let mut pair = pair.into_inner();
                let first = pair.next().unwrap();

                let op = pair.next();
                match op {
                    Some(op) => {
                        let lhs = first;
                        let rhs = parse_value(pair.next().unwrap());
                        match rhs {
                            Ok(value) => parse_expression(op, lhs, value),
                            Err(err) => AstNode::Error(err),
                        }
                    }
                    None => match parse_value(first) {
                        Ok(value) => AstNode::Value(value),
                        Err(error) => AstNode::Error(error),
                    },
                }
            }
        },
        Rule::function => {
            let mut pair = pair.into_inner();
            let function = pair.next().unwrap();

            let next = pair.next().unwrap();
            let value = match next.as_rule() {
                Rule::simple_expression => match evaluate_simple_expression(parse_to_ast(next)) {
                    Ok(value) => Ok(value),
                    Err(error) => Err(error),
                },
                Rule::number => match next.as_str().parse::<f64>() {
                    Ok(value) => Ok(value),
                    Err(_error) => Err(LannerError::InvalidInput),
                },
                _ => Err(LannerError::InvalidInput),
            };

            let function = parse_function(function);

            match function {
                Ok(function) => match value {
                    Ok(value) => AstNode::FunctionOp { value, function },
                    Err(error) => AstNode::Error(error),
                },
                Err(error) => AstNode::Error(error.to_owned()),
            }
        }
        Rule::abs => {
            let pair = pair.into_inner().next().unwrap();
            match parse_to_ast(pair) {
                AstNode::Value(v) => AstNode::Value(v.abs()),
                AstNode::Expression { lhs, rhs, operator } => AstNode::Value(
                    evaluate_simple_expression(AstNode::Expression { lhs, rhs, operator })
                        .unwrap()
                        .abs(),
                ),
                _ => AstNode::Error(LannerError::InvalidExpression),
            }
        }
        _ => AstNode::Error(LannerError::InvalidInput),
    }
}

/// Returns a given Constant variant from a string
fn parse_constant(v: pest::iterators::Pair<Rule>) -> Constant {
    match v.as_rule() {
        Rule::constant => {
            match v.as_str() {
                "E" => Constant::E,
                "Pi" => Constant::Pi,
                "Tau" => Constant::Tau,
                "i" => Constant::I,
                _ => Constant::I, // todo: fix
            }
        }
        _ => Constant::I, // todo: fix
    }
}

/// Parse a given value. Returns either a value derived from a constant or the given value as an `f64`
fn parse_value(v: pest::iterators::Pair<Rule>) -> Result<f64, LannerError> {
    match v.as_str() {
        "E" | "Pi" | "Tau" | "i" => match evaluate_constant(parse_constant(v)) {
            Ok(value) => Ok(value),
            Err(_error) => Err(LannerError::InvalidConstant),
        },
        _ => match v.as_str().parse::<f64>() {
            Ok(value) => Ok(value),
            Err(_error) => Err(LannerError::InvalidInput),
        },
    }
}

/// Converts a given Pest rule into an Expression in the AST
fn parse_expression(
    operator: pest::iterators::Pair<Rule>,
    lhs: pest::iterators::Pair<Rule>,
    rhs: f64,
) -> AstNode {
    let lhs = match lhs.as_rule() {
        Rule::constant => match evaluate_constant(parse_constant(lhs)) {
            Ok(value) => value,
            Err(e) => {
                0.0 // todo: fix
            }
        },
        _ => lhs.as_str().parse::<f64>().unwrap(),
    };

    AstNode::Expression {
        lhs: lhs,
        rhs: rhs,
        operator: parse_operator(operator),
    }
}

/// Converts a given Pest rule into an Operator in the AST
fn parse_operator(operator: pest::iterators::Pair<Rule>) -> Operation {
    match operator.as_str() {
        "+" => Operation::Add,
        "-" => Operation::Subtract,
        "*" => Operation::Multiply,
        "/" => Operation::Divide,
        "%" => Operation::Modulo,
        "^" => Operation::Exponent,
        "^/" => Operation::Root,
        _ => Operation::Add, // todo: fix
    }
}

/// Converts a given Pest rule into a Function in the AST
fn parse_function(function: pest::iterators::Pair<Rule>) -> Result<Function, LannerError> {
    match function.as_str() {
        "sin" => Ok(Function::Sin),
        "cos" => Ok(Function::Cos),
        "tan" => Ok(Function::Tan),
        "sqrt" => Ok(Function::Sqrt),
        "abs" => Ok(Function::Abs),
        _ => Err(LannerError::InvalidFunction),
    }
}

/// Evaluates a given expression, such as "10 + 10"
pub fn evaluate(src: &str) -> Result<f64, LannerError> {
    let ast = parse(src);
    match ast {
        Ok(ast) => {
            let pair = ast.get(0).unwrap();
            match pair {
                AstNode::FunctionOp {
                    function: _,
                    value: _,
                } => match evaluate_function(pair.to_owned()) {
                    Ok(result) => Ok(result),
                    Err(error) => Err(error.to_owned()),
                },
                AstNode::Expression {
                    lhs: _,
                    rhs: _,
                    operator: _,
                } => match evaluate_simple_expression(pair.to_owned()) {
                    Ok(result) => Ok(result),
                    Err(error) => Err(error.to_owned()),
                },
                AstNode::Value(value) => Ok(value.to_owned()),
                // will astnode::constant ever match? I don't think so
                AstNode::Constant(constant) => match evaluate_constant(constant.to_owned()) {
                    Ok(result) => Ok(result),
                    Err(error) => Err(error.to_owned()),
                },
                AstNode::Error(error) => Err(error.to_owned()),
                _ => Err(LannerError::InvalidInput),
            }
        }
        Err(error) => Err(LannerError::ParsingError(error)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn parse_fn_test() {
        //        parse("20 + 20");
        //        parse("sin(20)");
    }

    #[test]
    fn order_of_operations() {
        assert_eq!(evaluate("(10 - 10) * 10 + 10").unwrap(), 10.0);
    }

    #[test]
    fn abs_value() {
        assert_eq!(evaluate("|10-10|").unwrap(), 0.0);
        assert_eq!(evaluate("|-10-10|").unwrap(), 20.0);

        assert_eq!(evaluate("abs(10-10)").unwrap(), 0.0);
        assert_eq!(evaluate("abs(-10-10)").unwrap(), 20.0);
    }

    #[test]
    fn eval_constants() {
        assert_eq!(
            evaluate("Tau").unwrap(),
            6.28318530717958647692528676655900577
        );

        assert_eq!(
            evaluate("Tau + 1").unwrap(),
            7.28318530717958647692528676655900577
        );
    }

    #[test]
    fn addition_eval() {
        assert_eq!(evaluate("20 + 30").unwrap(), 50.0);
        assert_eq!(evaluate("-20 + 30").unwrap(), 10.0);
        assert_eq!(evaluate("-20 + -30").unwrap(), -50.0);
        assert_eq!(evaluate("-20.2 + 30").unwrap(), 9.8);
        assert_eq!(evaluate("10.1 + 0.1").unwrap(), 10.2);
    }

    #[test]
    fn subtraction_eval() {
        assert_eq!(evaluate("30 - 30").unwrap(), 0.0);
        assert_eq!(evaluate("20 - 30").unwrap(), -10.0);
        assert_eq!(evaluate("-20 - 30").unwrap(), -50.0);
        assert_eq!(evaluate("-20 - -30").unwrap(), 10.0);
        assert_eq!(evaluate("-20.2 - 30").unwrap(), -50.2);
        assert_eq!(evaluate("10.2 - 0.2").unwrap(), 10.0);
    }

    #[test]
    fn multiplication_eval() {
        assert_eq!(evaluate("30 * 30").unwrap(), 900.0);
        assert_eq!(evaluate("-30 * 30").unwrap(), -900.0);
        assert_eq!(evaluate("-20 * -30").unwrap(), 600.0);
        assert_eq!(evaluate("-20.2 * 30").unwrap(), -606.0);
        assert_eq!(evaluate("-20.2 * -30.3").unwrap(), 612.06);
    }

    #[test]
    fn division_eval() {
        assert_eq!(evaluate("30 / 30").unwrap(), 1.0);
        assert_eq!(evaluate("-30 / 30").unwrap(), -1.0);
        assert_eq!(evaluate("-20 / -30").unwrap(), 0.6666666666666666);
        assert_eq!(evaluate("-1.2 / 2").unwrap(), -0.6);
        assert_eq!(evaluate("-1.2 / -2").unwrap(), 0.6);
    }

    #[test]
    fn exponent_eval() {
        assert_eq!(evaluate("10 ^ 3").unwrap(), 1000.0);
        assert_eq!(evaluate("-10 ^ 2").unwrap(), 100.0);
        assert_eq!(evaluate("-10 ^ -2").unwrap(), 0.01);
        assert_eq!(evaluate("-10.2 ^ -0.5").unwrap().is_nan(), true);
    }

    #[test]
    fn test_cos() {
        assert_eq!(evaluate("cos(100)").unwrap(), 0.8623188722876839);
    }

    #[test]
    fn test_tan() {
        assert_eq!(evaluate("tan(500)").unwrap(), 0.52924386474448);
    }

    #[test]
    fn test_sin() {
        assert_eq!(evaluate("sin(500 + 500)").unwrap(), 0.8268795405320025);
    }

    #[test]
    fn test_sqrt() {
        assert_eq!(evaluate("sqrt(100)").unwrap(), 10.0);
    }
}

#[cfg(test)]
mod parser_tests {
    use super::*;

    #[test]
    fn check_number() {
        let whole = LannerParser::parse(Rule::number, "10");
        assert!(whole.is_ok());
        let integer = LannerParser::parse(Rule::number, "10.15");
        assert!(integer.is_ok());
    }

    #[test]
    fn check_fn() {
        let function = LannerParser::parse(Rule::function, "cos(20)");
        assert!(function.is_ok());
    }

    #[test]
    fn check_expression() {
        let exp = LannerParser::parse(Rule::expression, "10+10");
        assert!(exp.is_ok());

        let exp_with_spaces = LannerParser::parse(Rule::expression, "10 + 10");
        assert!(exp_with_spaces.is_ok());
    }
}
